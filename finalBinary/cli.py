#!/usr/bin/env python3
"""
rgw-monitor — CLI entry point for Ceph RGW Multisite Monitor.

Usage:
  rgw-monitor init                     Generate config and validate Ceph access
  rgw-monitor start                    Start the primary dashboard + collector
  rgw-monitor agent -u URL             Start the zone agent on a secondary site
  rgw-monitor test [--step N]          Run validation checks
  rgw-monitor status                   Check health of a running instance
"""

import argparse
import json
import os
import shutil
import sys
import textwrap

from . import __version__

BANNER = r"""
  ╔══════════════════════════════════════════════╗
  ║   Ceph RGW Multisite Monitor  v{ver:<12s}  ║
  ╚══════════════════════════════════════════════╝
""".rstrip()

DEFAULT_CONFIG = """\
# =====================================================
# Ceph RGW Multisite Monitor — Configuration
# =====================================================
# Generated by: rgw-monitor init
#
# This tool uses radosgw-admin CLI on the local host.
# It MUST run on a Ceph admin/mon node with cluster access.
#
# NO configuration is required for basic operation.
# The tool will auto-discover everything from the cluster.
# =====================================================

# Collection interval (seconds)
collection_interval: 60

# Optional: REST API for secondary zone bucket stats
# Enable when CLI --rgw-zone doesn't return remote zone stats.
use_rest_for_bucket_stats: false

# RGW Admin credentials (only if use_rest_for_bucket_stats: true)
# access_key: "YOUR_ACCESS_KEY"
# secret_key: "YOUR_SECRET_KEY"

# SSL verification for REST API calls
verify_ssl: false

# API server bind settings
api_host: "0.0.0.0"
api_port: 5000
"""


def find_config():
    """Search for config.yaml in standard locations."""
    candidates = [
        os.environ.get("RGW_MONITOR_CONFIG", ""),
        os.path.join(os.getcwd(), "config.yaml"),
        os.path.expanduser("~/.config/rgw-monitor/config.yaml"),
        "/etc/rgw-monitor/config.yaml",
    ]
    for path in candidates:
        if path and os.path.isfile(path):
            return path
    return None


# ------------------------------------------------------------------ #
#  rgw-monitor init
# ------------------------------------------------------------------ #

def cmd_init(args):
    """Generate config.yaml and validate Ceph cluster access."""
    print(BANNER.format(ver=__version__))
    print()

    config_path = args.config or os.path.join(os.getcwd(), "config.yaml")

    # Generate config
    if os.path.exists(config_path) and not args.force:
        print(f"  Config already exists: {config_path}")
        print(f"  Use --force to overwrite.")
    else:
        os.makedirs(os.path.dirname(config_path) or ".", exist_ok=True)
        with open(config_path, "w") as f:
            f.write(DEFAULT_CONFIG)
        print(f"  ✓ Config written: {config_path}")

    # Check radosgw-admin
    print()
    if shutil.which("radosgw-admin"):
        print("  ✓ radosgw-admin found on PATH")
    else:
        print("  ✗ radosgw-admin NOT found on PATH")
        print("    Install ceph-common or ensure radosgw-admin is accessible.")
        return 1

    # Validate cluster access
    import subprocess
    try:
        proc = subprocess.run(
            ["radosgw-admin", "realm", "get", "--format=json"],
            capture_output=True, text=True, timeout=10
        )
        if proc.returncode == 0:
            import json as _json
            try:
                realm = _json.loads(proc.stdout.strip())
                print(f"  ✓ Cluster access verified — realm: {realm.get('name', '?')}")
            except Exception:
                print("  ✓ Cluster access verified")
        else:
            print(f"  ⚠ realm get returned error (may be OK if no realm configured)")
            print(f"    stderr: {proc.stderr.strip()[:200]}")
    except subprocess.TimeoutExpired:
        print("  ✗ radosgw-admin timed out — check cluster connectivity")
        return 1
    except Exception as exc:
        print(f"  ✗ Error running radosgw-admin: {exc}")
        return 1

    # Ensure dashboard HTML is built
    _ensure_dashboard_built()

    print()
    print("  Ready! Next steps:")
    print(f"    rgw-monitor start              # start the primary dashboard")
    print(f"    rgw-monitor start -c {config_path}")
    print()
    return 0


def _ensure_dashboard_built():
    """Build dashboard/index.html if not present."""
    pkg_dir = os.path.dirname(os.path.abspath(__file__))
    dash_dir = os.path.join(pkg_dir, "dashboard")
    html_path = os.path.join(dash_dir, "index.html")
    build_script = os.path.join(dash_dir, "build_html.py")

    if os.path.isfile(html_path):
        return  # Already built

    if os.path.isfile(build_script):
        print("  Building dashboard HTML...")
        import subprocess
        proc = subprocess.run(
            [sys.executable, build_script],
            capture_output=True, text=True, cwd=dash_dir
        )
        if proc.returncode == 0:
            print("  ✓ Dashboard built")
        else:
            print(f"  ⚠ Dashboard build failed: {proc.stderr.strip()[:200]}")


# ------------------------------------------------------------------ #
#  rgw-monitor start
# ------------------------------------------------------------------ #

def cmd_start(args):
    """Start the primary dashboard (API server + collector)."""
    print(BANNER.format(ver=__version__))
    print()

    config_path = args.config or find_config()
    if config_path:
        print(f"  Config: {config_path}")
        os.environ["RGW_MONITOR_CONFIG"] = config_path
    else:
        print("  Config: (none — using defaults, run 'rgw-monitor init' to generate)")

    _ensure_dashboard_built()

    # Set log level
    import logging
    if args.debug:
        logging.basicConfig(level=logging.DEBUG,
                           format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
                           datefmt="%H:%M:%S")
        logging.getLogger("collector").setLevel(logging.DEBUG)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO,
                           format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
                           datefmt="%H:%M:%S")
    else:
        logging.basicConfig(level=logging.INFO,
                           format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
                           datefmt="%H:%M:%S")

    # Import and start
    from .server import app, start_collector_from_config

    start_collector_from_config()

    port = args.port or 5000
    host = args.host or "0.0.0.0"

    print()
    print(f"  Dashboard:  http://{host}:{port}")
    print(f"  API:        http://{host}:{port}/api/health")
    print(f"  Metrics:    http://{host}:{port}/metrics")
    print()

    app.run(host=host, port=port, debug=False, threaded=True)


# ------------------------------------------------------------------ #
#  rgw-monitor agent
# ------------------------------------------------------------------ #

def cmd_agent(args):
    """Start the zone agent on a secondary site."""
    # The agent is self-contained — import and delegate
    from .agent import main as agent_main

    # Build sys.argv for the agent's own argparse
    agent_argv = []
    if args.primary_url:
        agent_argv += ["--primary-url", args.primary_url]
    if args.interval:
        agent_argv += ["--interval", str(args.interval)]
    if args.zone:
        agent_argv += ["--zone", args.zone]
    if args.agent_config:
        agent_argv += ["--config", args.agent_config]
    if args.once:
        agent_argv.append("--once")
    if args.dry_run:
        agent_argv.append("--dry-run")
    if args.verbose:
        agent_argv.append("--verbose")
    if args.debug:
        agent_argv.append("--debug")

    # Override sys.argv and call agent main
    sys.argv = ["rgw-monitor agent"] + agent_argv
    agent_main()


# ------------------------------------------------------------------ #
#  rgw-monitor test
# ------------------------------------------------------------------ #

def cmd_test(args):
    """Run validation checks."""
    print(BANNER.format(ver=__version__))
    print()

    from .validate import run_step, run_all_steps

    config_path = args.config or find_config()

    if args.step:
        return run_step(args.step, verbose=args.verbose, config_path=config_path)
    else:
        return run_all_steps(verbose=args.verbose, config_path=config_path)


# ------------------------------------------------------------------ #
#  rgw-monitor status
# ------------------------------------------------------------------ #

def cmd_status(args):
    """Check health of a running rgw-monitor instance."""
    import urllib.request
    import urllib.error

    url = (args.url or "http://localhost:5000").rstrip("/")
    print(BANNER.format(ver=__version__))
    print()
    print(f"  Checking: {url}")
    print()

    # Health
    try:
        with urllib.request.urlopen(url + "/api/health", timeout=5) as resp:
            data = json.loads(resp.read().decode("utf-8"))
        ceph = "✓" if data.get("ceph_access") else "✗"
        coll = "✓ running" if data.get("collector_running") else "✗ stopped"
        print(f"  API:       ✓ reachable")
        print(f"  Ceph:      {ceph}")
        print(f"  Collector: {coll}")
    except Exception as exc:
        print(f"  API:       ✗ unreachable ({exc})")
        return 1

    # Zone agents
    try:
        with urllib.request.urlopen(url + "/api/zone-agents", timeout=5) as resp:
            agents = json.loads(resp.read().decode("utf-8"))
        if agents:
            print()
            print("  Zone Agents:")
            for zn, info in agents.items():
                stale = "✗ STALE" if info.get("stale") else "✓ active"
                age = info.get("age_seconds")
                age_str = f"{int(age)}s ago" if age is not None else "?"
                errs = info.get("error_count", 0)
                print(f"    {zn}: {stale} (last push: {age_str}, errors: {errs})")
        else:
            print("  Zone Agents: none connected")
    except Exception:
        pass

    # Quick bucket stats
    try:
        with urllib.request.urlopen(url + "/api/buckets", timeout=5) as resp:
            buckets = json.loads(resp.read().decode("utf-8"))
        if buckets:
            print()
            print(f"  Buckets: {len(buckets)} monitored")
            high = sum(1 for b in buckets if b.get("sync_progress_pct", 100) < 85)
            synced = sum(1 for b in buckets if b.get("sync_progress_pct", 0) >= 99)
            print(f"    SYNCED: {synced}  |  HIGH priority: {high}")
    except Exception:
        pass

    print()
    return 0


# ------------------------------------------------------------------ #
#  Main
# ------------------------------------------------------------------ #

def main():
    parser = argparse.ArgumentParser(
        prog="rgw-monitor",
        description="Ceph RGW Multisite Replication Monitor",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent("""\
            Quick start:
              rgw-monitor init                     Validate Ceph access, generate config
              rgw-monitor start                    Start the primary dashboard
              rgw-monitor agent -u http://HOST:5000 Start zone agent on secondary

            Full docs: https://github.com/your-org/rgw-multisite-monitor
        """),
    )
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")

    sub = parser.add_subparsers(dest="command", help="Available commands")

    # init
    p_init = sub.add_parser("init", help="Generate config and validate Ceph access")
    p_init.add_argument("--config", "-c", default=None, help="Config file path (default: ./config.yaml)")
    p_init.add_argument("--force", "-f", action="store_true", help="Overwrite existing config")

    # start
    p_start = sub.add_parser("start", help="Start the primary dashboard + collector")
    p_start.add_argument("--config", "-c", default=None, help="Config file path")
    p_start.add_argument("--port", "-p", type=int, default=None, help="API port (default: 5000)")
    p_start.add_argument("--host", default=None, help="Bind host (default: 0.0.0.0)")
    p_start.add_argument("--verbose", "-v", action="store_true", help="Verbose logging")
    p_start.add_argument("--debug", "-d", action="store_true", help="Debug logging")

    # agent
    p_agent = sub.add_parser("agent", help="Start zone agent on a secondary site")
    p_agent.add_argument("--primary-url", "-u", required=False, help="Primary dashboard URL")
    p_agent.add_argument("--interval", "-i", type=int, default=None, help="Push interval (default: 60s)")
    p_agent.add_argument("--zone", "-z", default=None, help="Zone name (default: auto-detect)")
    p_agent.add_argument("--agent-config", default=None, help="Agent config YAML file")
    p_agent.add_argument("--once", action="store_true", help="Single cycle then exit")
    p_agent.add_argument("--dry-run", action="store_true", help="Collect and print, don't push")
    p_agent.add_argument("--verbose", "-v", action="store_true", help="Verbose logging")
    p_agent.add_argument("--debug", "-d", action="store_true", help="Debug logging")

    # test
    p_test = sub.add_parser("test", help="Run validation checks")
    p_test.add_argument("--step", "-s", type=int, default=None, help="Run specific step (1-9)")
    p_test.add_argument("--config", "-c", default=None, help="Config file path")
    p_test.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    # status
    p_status = sub.add_parser("status", help="Check health of a running instance")
    p_status.add_argument("--url", default=None, help="Instance URL (default: http://localhost:5000)")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    handlers = {
        "init": cmd_init,
        "start": cmd_start,
        "agent": cmd_agent,
        "test": cmd_test,
        "status": cmd_status,
    }
    return handlers[args.command](args) or 0


if __name__ == "__main__":
    sys.exit(main())
